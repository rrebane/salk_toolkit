# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_dashboard.ipynb.

# %% auto 0
__all__ = ['draw_plot_matrix', 'st_plot', 'get_plot_width', 'open_fn', 'read_annotated_data_cached', 'load_json_cached',
           'save_json', 'alias_file', 'SalkDashboardBuilder']

# %% ../nbs/05_dashboard.ipynb 3
import json, os, inspect
import itertools as it
from collections import defaultdict

import numpy as np
import pandas as pd
import polars as pl
import datetime as dt

from typing import List, Tuple, Dict, Union, Optional

import altair as alt
import s3fs

from salk_toolkit.utils import *
from salk_toolkit.io import *
from salk_toolkit.pp import e2e_plot

import streamlit as st
from streamlit_option_menu import option_menu
from streamlit_dimensions import st_dimensions
import streamlit_authenticator as stauth

# %% ../nbs/05_dashboard.ipynb 4
# This is a horrible workaround to get faceting to work with altair geoplots that do not play well with streamlit
# See https://github.com/altair-viz/altair/issues/2369 -> https://github.com/vega/vega-lite/issues/3729

# Draw a matrix of plots using separate plots and st columns
def draw_plot_matrix(pmat,matrix_form = False):
    if not matrix_form: pmat = [[pmat]]
    cols = st.columns(len(pmat[0]))
    for j,c in enumerate(cols):
        for i, row in enumerate(pmat):
            c.altair_chart(pmat[i][j])

# Draw the plot described by pp_desc 
def st_plot(pp_desc,**kwargs):
    matrix_form = (pp_desc['plot'] == 'geoplot')
    plots = e2e_plot(pp_desc, return_matrix_of_plots=matrix_form, **kwargs)
    draw_plot_matrix(plots, matrix_form=matrix_form)

# %% ../nbs/05_dashboard.ipynb 5
def get_plot_width(key):
    wobj = st_dimensions(key=key) or { 'width': 900 }# Can return none so handle that
    return int(0.85*wobj['width']) # Needs to be adjusted down  to leave margin for plots

# %% ../nbs/05_dashboard.ipynb 6
# Open either a local or an s3 file
def open_fn(fname, *args, s3_fs=None, **kwargs):
    if fname[:3] == 's3:':
        if s3_fs is None: s3_fs = s3fs.S3FileSystem(anon=False)
        return s3_fs.open(fname,*args,**kwargs)
    else:
        return open(fname,*args,**kwargs)

# %% ../nbs/05_dashboard.ipynb 7
# ttl=None - never expire. Makes sense for potentially big data files
@st.cache_resource(show_spinner=False,ttl=None)
def read_annotated_data_cached(data_source,**kwargs):
    return read_annotated_data(data_source,**kwargs)


# This is cached very short term (1 minute) to avoid downloading it on every page change
# while still allowing users to be added / changed relatively responsively
@st.cache_resource(show_spinner=False,ttl=60)
def load_json_cached(fname, _s3_fs=None, **kwargs):
    with open_fn(fname,'r',s3_fs=_s3_fs) as jf:
        return json.load(jf)

# For saving json back 
def save_json(d, fname, _s3_fs=None, **kwargs):
    with open_fn(fname,'w',s3_fs=_s3_fs) as jf:
        json.dump(d,jf)
        
def alias_file(fname, file_map):
    if fname[:3]!='s3:' and fname in file_map and not os.path.exists(fname):
        #print(f"Redirecting {fname} to {file_map[fname]}")
        return file_map[fname]
    else: return fname

# %% ../nbs/05_dashboard.ipynb 8
# Main dashboard wrapper - WIP
class SalkDashboardBuilder:

    def __init__(self, data_source, auth_conf, public=False):
        
        # Allow deployment.json to redirect files from local to s3 if local missing (i.e. in deployment scenario)
        if os.path.exists('deployment.json'):
            dep_meta = load_json_cached('deployment.json')
            filemap = vod(dep_meta,'files',{})
            data_source = alias_file(data_source,filemap)
            auth_conf = alias_file(auth_conf,filemap)
        
        self.s3fs = s3fs.S3FileSystem(anon=False) # Initialize s3 access. Key in secrets.toml
        self.data_source = data_source
        self.public = public
        self.pages = []
        self.sb_info = st.sidebar.empty()
        
        # Load data
        with st.spinner("Loading data..."):
            self.df, self.meta = read_annotated_data_cached(data_source)
        
        # Set up authentication
        with st.spinner("Setting up authentication..."):
            config = load_json_cached(auth_conf, _s3_fs = self.s3fs)
            self.auth_conf_data, self.auth_conf_file = config, auth_conf
            self.auth = stauth.Authenticate(
                config['credentials'],
                config['cookie']['name'],
                config['cookie']['key'],
                config['cookie']['expiry_days'],
                config['preauthorized']
            )
            self.users = config['credentials']['usernames']

        if not public:
            if st.session_state["authentication_status"] is False:
                st.error('Username/password is incorrect')
            if st.session_state["authentication_status"] is None:
                st.warning('Please enter your username and password')
            self.auth.login('Login', 'main')

        uname = st.session_state['username']
        self.user = {'name': st.session_state['name'], 
                     'username': uname,
                     **self.users[uname] } if st.session_state["authentication_status"] else {}
        
    def save_auth_conf(self):
        with open_fn(self.auth_conf_file,'w',s3_fs=self.s3fs) as jf:
            json.dump(self.auth_conf_data,jf)

    # pos_id is for plot_width to work in columns
    def plot(self, pp_desc, pos_id=None, **kwargs):
        st_plot(pp_desc,
                width=min(get_plot_width(pos_id or 'full'),800),
                full_df=self.df,data_meta=self.meta,**kwargs)

    def page(self, name, **kwargs):
        def decorator(pfunc):
            groups = vod(kwargs,'groups')
            if (groups is None or # Page is available to all
                vod(self.user,'group')=='admin' or # Admin sees all
                vod(self.user,'group','guests') in groups): # group is whitelisted
                self.pages.append( (name,pfunc,kwargs) )
        return decorator

    def build(self):    
        # If login failed and is required, don't go any further
        if not self.public and not st.session_state["authentication_status"]: return
    
        # Add user settings page if logged in
        if st.session_state["authentication_status"]:  self.pages.append( ('Settings',user_settings_page,{'icon': 'sliders'}) )
        
        # Add admin page for admins
        if vod(self.user,'group')=='admin':  self.pages.append( ('Admin',admin_page,{'icon': 'terminal'}) )
        
        # Draw the menu listing pages
        pnames = [t[0] for t in self.pages]
        with st.sidebar:
            
            if st.session_state["authentication_status"]:
                self.sb_info.info(f'Logged in as **{self.user["name"]}**')
                self.auth.logout('Logout', 'sidebar')
            
            menu_choice = option_menu("Pages",
                pnames, icons=[vod(t[2],'icon') for t in self.pages],
                styles={
                    "container": {"padding": "5!important"}, #, "background-color": "#fafafa"},
                    #"icon": {"color": "red", "font-size": "15px"},
                    "nav-link": {"font-size": "12px", "text-align": "left", "margin":"0px", "--hover-color": "#eee"},
                    "nav-link-selected": {"background-color": "#red"},
                    "menu-title": {"display":"none"}
                })
            
        # Render the chosen page
        pname, pfunc, meta = self.pages[pnames.index(menu_choice)]
        st.title(pname)
        pfunc(**clean_kwargs(pfunc,{'sdb':self}))
        
    # Add enter and exit so it can be used as a context
    def __enter__(self):
        return self
    
    # Render everything once we exit the with block
    def __exit__(self, exc_type, exc_value, exc_tb):
        self.build()
    
        

# %% ../nbs/05_dashboard.ipynb 9
def admin_page(sdb):
    st.write('**Under construction**')
    pass

def user_settings_page(sdb):
    if not st.session_state["authentication_status"]: return
    try:
        if sdb.auth.reset_password(st.session_state["username"], 'Reset password'):
            sdb.save_auth_conf()
            st.success('Password modified successfully')
    except Exception as e:
        st.error(e)
