# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10_utils.ipynb.

# %% auto 0
__all__ = ['vod', 'factorize_w_codes', 'batch', 'loc2iloc', 'replace_constants', 'index_encoder', 'to_alt_scale',
           'multicol_to_vals_cats', 'gradient_to_discrete_color_scale']

# %% ../nbs/10_utils.ipynb 3
import json, os
import itertools as it
from collections import defaultdict

import numpy as np
import pandas as pd
import datetime as dt

import altair as alt
import matplotlib.colors as mpc
from copy import deepcopy

from typing import List, Tuple, Dict, Union, Optional

# %% ../nbs/10_utils.ipynb 4
# Value or Default - returns key value in dict if key in dict, otherwise Mone
def vod(d,k,default=None): return d[k] if k in d else default

# %% ../nbs/10_utils.ipynb 5
# I'm surprised pandas does not have this function but I could not find it. 
def factorize_w_codes(s, codes):
    res = s.replace(dict(zip(codes,range(len(codes)))))
    if not s.isin(codes).all(): # Throw an exception if all values were not replaced
        vals = set(s) - set(codes)
        raise Exception(f'Codes for {s.name} do not match all values: {vals}')
    return res.to_numpy()

# %% ../nbs/10_utils.ipynb 6
# Simple batching of an iterable
def batch(iterable, n=1):
    l = len(iterable)
    for ndx in range(0, l, n):
        yield iterable[ndx:min(ndx + n, l)]

# %% ../nbs/10_utils.ipynb 7
# turn index values into order indices
def loc2iloc(index, vals):
    d = dict(zip(np.array(index),range(len(index))))
    return [ d[v] for v in vals ]

# %% ../nbs/10_utils.ipynb 8
# Allow 'constants' entries in the dict to provide replacement mappings
# This leads to much more readable jsons as repetitions can be avoided
def replace_constants(d, constants = {}, inplace=False):
    if not inplace: d = deepcopy(d)
    if type(d)==dict and 'constants' in d:
        constants = constants.copy() # Otherwise it would propagate back up through recursion - see test6 below
        constants.update(d['constants'])
        del d['constants']

    for k, v in (d.items() if type(d)==dict else enumerate(d)):
        if type(v)==str and v in constants:
            d[k] = constants[v]
        elif type(v)==dict or type(v)==list:
            d[k] = replace_constants(v,constants, inplace=True)
            
    return d

# %% ../nbs/10_utils.ipynb 10
# JSON encoder needed to convert pandas indices into lists for serialization
def index_encoder(z):
    if isinstance(z, pd.Index):
        return list(z)
    else:
        type_name = z.__class__.__name__
        raise TypeError(f"Object of type {type_name} is not serializable")

# %% ../nbs/10_utils.ipynb 11
# Helper function to turn a dictionary into an Altair scale (or None into alt.Undefined)
def to_alt_scale(scale):
    if scale is None: scale = alt.Undefined
    if isinstance(scale,dict):
        scale = alt.Scale(domain=list(scale.keys()),range=list(scale.values()))
    return scale

# %% ../nbs/10_utils.ipynb 12
# Turn a question with multiple variants all of which are in distinct columns into a two columns - one with response, the other with which question variant was used

def multicol_to_vals_cats(df, cols=None, col_prefix=None, reverse_cols=[], reverse_suffixes=None, cat_order=None, vals_name='vals', cats_name='cats', inplace=False):
    if not inplace: df = df.copy()
    if cols is None: cols = [ c for c in df.columns if c.startswith(col_prefix)]
    
    if not reverse_cols and reverse_suffixes is not None:
        reverse_cols = [ c for c in cols for rs in reverse_suffixes if c.endswith(rs)]
    
    if reverse_cols:
        remap = dict(zip(cat_order,reversed(cat_order)))
        df.loc[:,reverse_cols].replace(remap,inplace=True)
    
    tdf = df[cols]
    cinds = np.argmax(tdf.notna(),axis=1)
    df.loc[:,vals_name] = np.array(tdf)[range(len(tdf)),cinds]
    df.loc[:,cats_name] = np.array(tdf.columns)[cinds]
    return df

# %% ../nbs/10_utils.ipynb 13
# Grad is a list of colors
def gradient_to_discrete_color_scale( grad, num_colors):
    cmap = mpc.LinearSegmentedColormap.from_list('grad',grad)
    return [mpc.to_hex(cmap(i)) for i in np.linspace(0, 1, num_colors)]
